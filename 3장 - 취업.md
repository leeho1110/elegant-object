# 3장 - 취업

### 1. 5개 이하의 public 메서드만 노출하세요

- 클래스의 작음을 결정하는 기준은 라인 수가 아닙니다. 바로 `public` 메서드의 수입니다.
    - 저자는 적당한 클래스의 크기를 5개의 `public` 메서드로 권고합니다.
    - 자연스럽게 코드의 양이 줄어들고, 메서드 수도 적어집니다. 이는 코드 베이스를 이해하는 시간이 짧아지고, 버그가 발생할 확률도 줄어들죠.
    - 유지보수성을 극대화시킬 수 있는 방법입니다.

---

### 2. 정적 메서드를 사용하지 마세요

- 정적 메서드를 사용하지 말라는 이유도 역시 유지보수성입니다.
    - 절차지향의 흐름에서는 명령의 실행 흐름을 우리가 제어합니다.
        - 컴퓨터는 우리를 위해서 일하는 도구이고, 우린 명령어를 통해 지시를 내리죠.
    - 하지만 객체지향에선 객체들을 정의하기만 할 뿐 흐름을 제어하는 역할을 객체에게 위임해야 합니다.
    - 그리고 CPU에게 “어떤 동작을 시행하라” 라고 지시하는 것이 아닌 **우리가 무엇을 원하는지를 표현**해야 합니다. 그리고 그걸 **정의**해야하죠.
        
        ```java
        // computer thinking
        int max(int a, int b){
        	if(a > b){
        		return a;
        	}
        	return b;
        }
        
        // functional
        int x = max(5,9);
        ```
        
- 프로그램의 상태를 변경하는 문장을 사용하는 **명령형 프로그래밍**, 어떤 계산을 해야하는지를 표현하는 **선언형 프로그래밍**
    - 선언형은 객체가 수행한 뒤 뱉어낼 결과를 표현합니다. 하지만 명령형은 객체가 수행할 방식을 이야기합니다.
        - 고로 내부 구현을 메서드를 통해서 명시하고 있는 것이죠.
        - 이는 우리가 객체지향에서 지향해야하는 캡슐화와 반대 방향으로 간다는 증거입니다.
    - 필자는 선언형 프로그래밍이 더 나은 이유로 최적화와 성능 등을 이야기하고 있지만, 썩 공감이 되진 않습니다.
        - 오히려 그 뒤의 다형성과 표현력의 이유가 좀더 와닿습니다.
- 유틸리티 클래스와 싱글톤 디자인 패턴은 최대한 사용하지 않는 것을 권장합니다.
    - 유틸리티 클래스와 싱글톤 클래스의 차이는 인스턴스를 set, get할 수 있느냐의 차이입니다.
        - 우리가 위 클래스들을 테스트해야할 때 **정적 메서드는 테스트가 불가능**합니다. 해당 객체를 모킹할 수 없기 때문이죠.
        - 하지만 싱글톤은 `setInstance()` 를 통해 가능합니다. 차라리 낫죠.
- 가능하다면 **데코레이터 패턴**을 사용하세요.
    - 객체들의 전체적인 행동들은 내부에 캡슐화됩니다.

---