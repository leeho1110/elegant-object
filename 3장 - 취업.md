# 3장 - 취업

### 1. 5개 이하의 public 메서드만 노출하세요

- 클래스의 작음을 결정하는 기준은 라인 수가 아닙니다. 바로 `public` 메서드의 수입니다.
    - 저자는 적당한 클래스의 크기를 5개의 `public` 메서드로 권고합니다.
    - 자연스럽게 코드의 양이 줄어들고, 메서드 수도 적어집니다. 이는 코드 베이스를 이해하는 시간이 짧아지고, 버그가 발생할 확률도 줄어들죠.
    - 유지보수성을 극대화시킬 수 있는 방법입니다.

---

### 2. 정적 메서드를 사용하지 마세요

- 정적 메서드를 사용하지 말라는 이유도 역시 유지보수성입니다.
    - 절차지향의 흐름에서는 명령의 실행 흐름을 우리가 제어합니다.
        - 컴퓨터는 우리를 위해서 일하는 도구이고, 우린 명령어를 통해 지시를 내리죠.
    - 하지만 객체지향에선 객체들을 정의하기만 할 뿐 흐름을 제어하는 역할을 객체에게 위임해야 합니다.
    - 그리고 CPU에게 “어떤 동작을 시행하라” 라고 지시하는 것이 아닌 **우리가 무엇을 원하는지를 표현**해야 합니다. 그리고 그걸 **정의**해야하죠.
        
        ```java
        // computer thinking
        int max(int a, int b){
        	if(a > b){
        		return a;
        	}
        	return b;
        }
        
        // functional
        int x = max(5,9);
        ```
        
- 프로그램의 상태를 변경하는 문장을 사용하는 **명령형 프로그래밍**, 어떤 계산을 해야하는지를 표현하는 **선언형 프로그래밍**
    - 선언형은 객체가 수행한 뒤 뱉어낼 결과를 표현합니다. 하지만 명령형은 객체가 수행할 방식을 이야기합니다.
        - 고로 내부 구현을 메서드를 통해서 명시하고 있는 것이죠.
        - 이는 우리가 객체지향에서 지향해야하는 캡슐화와 반대 방향으로 간다는 증거입니다.
    - 필자는 선언형 프로그래밍이 더 나은 이유로 최적화와 성능 등을 이야기하고 있지만, 썩 공감이 되진 않습니다.
        - 오히려 그 뒤의 다형성과 표현력의 이유가 좀더 와닿습니다.
- 유틸리티 클래스와 싱글톤 디자인 패턴은 최대한 사용하지 않는 것을 권장합니다.
    - 유틸리티 클래스와 싱글톤 클래스의 차이는 인스턴스를 set, get할 수 있느냐의 차이입니다.
        - 우리가 위 클래스들을 테스트해야할 때 **정적 메서드는 테스트가 불가능**합니다. 해당 객체를 모킹할 수 없기 때문이죠.
        - 하지만 싱글톤은 `setInstance()` 를 통해 가능합니다. 차라리 낫죠.
- 가능하다면 **데코레이터 패턴**을 사용하세요.
    - 객체들의 전체적인 행동들은 내부에 캡슐화됩니다.

---

### 3. 인자의 값으로 NULL을 절대 허용하지 마세요

- `NULL` 은 기본적으로 객체를 존중하지 않습니다.
- 심지어 중요하지 않은 `NULL` 방어 로직까지 추가됩니다.

---

### 4. 충성스러우면서 불변이거나, 아니면 상수이거나

- 불변 객체는 충성스럽습니다.
    - 가변 객체는 내부의 상태가 변경될 수 있기에 인스턴스는 저마다의 식별자를 가져야 합니다.
    - 하지만 불변 객체는 초기화가 된 이후엔 내부 상태를 변경할 수 없으므로, **상태값이 동일하다면 항상 같은 객체로 판단**합니다.
    - 고로 어떤 경우에도 표현하고자 하는 실세계의 대상을 배신하지 않습니다. 자신의 생명주기가 끝날 때까지 절대 자신이 가리키는 좌표의 위치를 변경하지 않죠. 이것이 우리가 충성스럽다고 표현할 수 있는 이유입니다.

---

### 5. 절대 getter와 setter를 사용하지 마세요

- `getter` , `setter` 는 근본적으로 캡슐화 원칙을 위반합니다.
    - 필자는 자바에서 둘을 도입한 이유가 클래스를 자료구조로 바꾸기 위함이라고 말합니다.
    - 그 이유는 **둘 모두 데이터에 직접 접근**하기 때문이죠.
- 실제로 네이밍에서도 문제를 갖습니다.
    - `get`, `set` 이라는 접두사로 인해 객체로 존중받지 못하고 꺼내오거나 채우는 자료구조라는 인식을 주죠.

---

### 6. 부 ctor 밖에서는 new를 사용하지 마세요

- 위 규칙을 지키면 객체들이 서로 분리되며 테스트 용이성과 유지보수성을 향상시킬 수 있습니다.
    
    ```java
    public class Cash {
    		private final int dollars;
    
    		public int euro(){
    				return new Exchange().rate("USD","EUR") * this.dollars;
    		}
    }
    ```
    
    - 위 코드에서 만약 `rate()` 가 외부 API 와 통신해야 한다면 어떻게 할까요?
    - 어떻게 하질 못합니다. 방법이 없어요. `euro()` 를 테스트할 때마다 네트워크 통신이 발생합니다.
    - 따라서 이 경우 Exchange 타입의 변수를 외부에서 생성해서 주입받는 DI 형태로 변경해야 합니다.
        
        ```java
        public class Cash {
        		private final int dollars;
        		private final Exchange exchane;
        
        		private Cash(int value, **Exchange exchange**){
        				this.dollars = value;
        				**this.exchane = exchane;**
        		}
        
        		public int euro(){
        				return **this.exchange.rate**("USD","EUR") * this.dollars;
        		}
        }
        ```
        
        - **외부에서 의도된 동작을 수행하는 모킹된 Exchange 타입 변수를 주입**해 테스트가 가능해집니다.

---