# 4장 - 은퇴

### 1. 절대 NULL을 반환하지 마세요

- 우린 항상 객체를 존중해야 합니다. 하지만 만약 NULL을 반환하게 된다면 우린 객체를 신뢰할 수 없습니다.
    - 결국 우린 객체를 특별히 ‘소중하게’ 다뤄야 합니다. 이것은 큰 문제입니다.
    - 객체가 반환하는 값들을 우린 매번 검증해야 합니다.
    - 객체지향은 책임을 다른 객체에게 ‘위임’합니다. 그런데 만약 내가 일을 맡길 사람이 믿을 수 있다면 과연 일을 맡기실 건가요? 그런 멍청한 짓을 하는 바보는 없습니다.
- 이는 결국 또 다시 유지보수성의 하락을 가져옵니다.
    - NULL을 반환하기보단 빠르게 예외를 던지세요. 이는 **빠르게 실패하기 원칙(fail fast principle)과 연관**이 있습니다.
- 소프트웨어에는 **빠르게 실패하기**와 **안전하게 실패하기**가 존재합니다.
    - ‘안전하게 실패하기’는 어떤 상황에도 소프트웨어가 최대한 동작하도록 합니다.
    - 반면 ‘빠르게 실패하기’는 문제가 발생한다면 바로 소프트웨어의 실행을 중단하고 예외를 던집니다.
        - 이 경우 실패를 감추는 것이 아닌 오히려 부각시킵니다. 또한 이를 추적할 수 있도록 만듭니다. 이전가 다르게 오히려 실패에 대한 모든 정보를 노출시킵니다.
    - 오래 숨길수록 문제는 곪아갑니다.
- NULL을 반환한다는 것 자체가 안전하게 실패하는 것입니다. 존재하지 않는 값이 반환됐다면, 어떤 행위도 존재하지 않는 값으로 수행할 수 없습니다. 고로 **실패하는 것이 더 올바른 방향**입니다.
    - 만약 컬렉션을 반환한다면 빈 컬렉션을 반환하는 것이 더 낫습니다.

---

### 2. 체크 예외(checked exception)만 던지세요

- 필자는 체크 예외를 사용함으로써 가시성을 향상시킨다고 말합니다.
    - 체크 예외를 발생시키고 이를 해결하는 과정을 통해 객체의 신뢰성을 향상시킨다는 말이 같은 논조라고 보여집니다.
    - 이를 통해 우린 객체를 신뢰하여 ‘해롭고 안전하지 않은 메서드’를 다루게 됩니다.
        - 사실 크게 동의하진 않습니다.
    - 언체크 예외를 통해서도 사실 빠르게 실패하고 객체의 요청에 실패로 답하는 것도 나쁘지 않다고 생각합니다.
    - 하지만 반드시 체크 예외를 사용해야하는 경우라면 필자의 의견을 주의깊게 들을 필요가 있습니다.
- 반드시 예외를 잡아 복구해야하는 상황이 아니라면 상위 레벨로 예외를 전파하세요.
- 만약 예외가 잡힌다면 이를 전파할 때 예외를 되던지세요.
    - 이는 문제가 발생한 근본적인 원인을 상위 레벨에서 알 수 있도록 한다는 점입니다.

---

### 3. final이거나 abstract이거나

- 사실 상속은 ‘반드시’ 나쁜 것이 아닙니다. 올바르게 사용되길 바랄 뿐입니다.
    - 만약 오버라이딩된 메서드로 인해 구현이 상속되는 부분에서 문제가 생긴다면 올바르지 않은 사용입니다.
- 고로 만약 구현 상속을 필요로 한다면 **메서드에 final 키워드를 통해 상속이 불가능**하게 만들어야 합니다. 아니라면 **abstract로 선언해 각기 다른 구현**을 가져야 합니다.