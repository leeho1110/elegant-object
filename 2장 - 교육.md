# 2장 - 교육

### 1. 가능하면 적게 캡슐화하세요

- 객체가 내부적으로 객체 4개 이상을 캡슐화하고 있다면 다시 고려해보세요.
    - 쉽게 인스턴스 필드라고 표현하겠습니다. 객체 안에 4개 이상의 객체가 각각의 좌표를 갖고 있다면 이해하기 어렵습니다.

---

### 2. 최소한 뭔가는 캡슐화하세요

- 그 어떤 것도 캡슐화하고 있지 않다면 모든 객체는 어디에서든 항상 동일합니다.
    - 즉 객체가 인스턴스화 되더라도 어떤 상태나 식별자를 가지지 않고, 단순히 행동만을 포함하는 것이죠.

---

### 3. 항상 인터페이스를 사용하세요

- 객체들은 서로 자유롭게 소통하고 협력합니다. 서로를 도와주기도 하죠.
    - 이 과정에서 자연스럽게 서로가 필요합니다. 이를 우린 객체가 **‘결합된다(Coupled)’** 라고 표현합니다.
    - 하지만 수십개의 객체들이 서로 결합되면 강한 결합도를 갖는 것이 문제로 떠오릅니다.
    - 이를 해결하기 위해 객체가 서로 너무 끈끈하지 않도록 분리해줘야 하는데 이때 인터페이스가 그 역할을 착실하게 해냅니다.
- 예를 들어 금액을 표현하는 객체가 존재하고 이를 사용하는 Employee가 필요하다면 아래와 같이 구현할 수 있습니다.
    - 금액을 표현하는 객체를 클래스와 인터페이스를 통해 표현
        
        ```java
        public interface Cash {
        		Cash multiply(float factor);
        }
        
        public class DefaultCash implements Cash {
        		private int dollars;
        		
        		public DefaultCash(int dlr){
        				this.dollars = dlr;
        		}
        
        		@Override
        		Cash multiply(float factor){
        				return new DefaultCash(this.dollars * factor);
        		}
        }
        ```
        
    - 이를 사용하는 Employee는 실제 객체인 DefaultCash가 아닌 계약 ‘Cash’ 에만 의존
        
        ```java
        public class Employee {
        		private Cash salary;
        
        		public void doSomeThingWithCash(){
        				...
        				salaray.multifly(3.1);
        				...
        		}
        }
        ```
        
        - Employee는 Cash의 multiply가 어떻게 구현되었는지 모르며, 관심을 가질 필요도 없습니다.
        - 즉 객체가 객체끼리 실제 구현 방법을 다루는 ‘구현체의 타입’에 대한 의존성을 가지지 않습니다.
    - 이는 결국 서로 객체가 캡슐화된 채로 **‘느슨하게 결합’**되어 있다는 것을 의미합니다.

---

### 4. 메서드 이름을 신중하게 선택하세요

- 빌더의 이름은 **명사**로, 조정자(manipulator)의 이름은 **동사**로 지으세요.
    - 빌더는 무언가를 만들고 객체를 반환하는 메서드입니다.
        - 반환 타입은 반드시 어떤 타입이어야만 합니다. 절대 `void` 가 될 수 없어요.
    - 조정자는 객체를 수정하는 메서드입니다.
        - 반환 타입은 반드시 `void` 이어야만 합니다.
- 빌더와 조정자는 각각의 역할만을 수행해야만 합니다. 둘 사이에 무언가가 존재해선 안됩니다.
    - 무언가를 조작하고 반환한다거나, 무언가를 만들며 조작하는 메서드는 있어선 안됩니다.

---

### 5. 퍼블릭 상수(Public Constant)를 사용하지 마세요

- 퍼블릭 상수는 결합도를 높히며 응집도를 낮춥니다.
    - 상수를 호출해 사용하는 방식은 객체가 변경되면 그 여파가 의존하는 객체에게 곧바로 전달됩니다.
    - 상수를 호출한다는 것은 특정 상태를 다른 객체로부터 매번 빌려온다는 것입니다. 이는 자신에게 필요한 정보가 스스로에게 없다는 것이죠.

---

### 6. 불변 객체로 만드세요

- 우리가 더 나은 객체지향을 하는 목적은 작은 크기, 높은 응집력, 느슨한 결합 등을 통해 유지보수성을 높히기 위함이었습니다. 불변성 역시 이에 큰 도움이 됩니다.
    - ‘불변성(immuatability)’은 인스턴스를 생성한 후에 상태를 변경할 수 없는 것을 의미합니다.
    - 자바에서는 `final` 키워드를 통해서 해당 객체가 최초 할당된 뒤 변경을 불가능하도록 합니다.
    - 저자는 가변 객체의 사용을 ‘엄격하게’ 금지하고 있습니다.
- 불변 객체를 통해 얻는 장점 중 하나는 **‘식별자 가변성(Identity mutability)’**입니다.
    - 예를 들어 최초 정수 5 값을 갖는 객체와 10 값을 갖는 객체가 **Map에 키로써 존재**한다고 가정해봅시다.
        - 가장 처음 두 객체는 다른 식별자를 갖습니다.
        - 하지만 5 값을 갖는 객체에 2를 곱하는 연산을 수행한 경우 둘은 동일한 값을 갖게 됩니다.
        - 하지만 Map 자료구조는 이를 인지하지 못하는 버그가 발생합니다.
- 두 번째는 **‘실패 원자성(Failure atomicity)’**입니다.
    - 만약 객체 내의 2가지 필드의 값을 변경한다고 가정해봅시다.
        - 불변 객체는 내부 상태를 변경할 수 없으므로, 만약 변경을 원한다면 언제나 새로운 객체를 반환합니다.
        - 반면 가변 객체는 2가지 중 한가지만 온전히 변경되고, **나머지 1개를 변경할 때 예외가 발생해 온전한 변경을 실패**할 수도 있습니다. 이 경우 우린 이를 발견하기 쉽지 않습니다.
- 세 번째는 **‘시간적 결합(Temporal Coupling)’**입니다.
    - 가변 객체는 `setter` 를 통해 객체의 상태를 변경합니다.
    - 이는 객체가 생성된 뒤 어디서든 변경의 가능성이 존재한다는 것을 의미합니다. **‘어느 시점에 변경되었는지’를 추적하는 상황은 유지보수성의 하락을 초래**합니다.
    - 반면 불변 객체는 ‘항상’ 하나의 라인, 객체를 인스턴스화함과 동시에 변경을 허용하지 않기 때문에 위 문제를 깔끔하게 해결합니다.
- 네 번째는 **‘부수효과 제거(Side effect-free)’**입니다.
- 객체를 불변 상태로 만들면 객체에 `null` 할당이 불가능합니다.
    - 이는 미래의 `null` 방어 코드를 방지합니다.
- 객체가 수정이 가능하다면 **멀티 스레드 상황에서 동시성 문제가 발생**할 수 있습니다.
    - 불변 객체로 발생한 경우, 객체를 수정하기 위해 접근하는 **Race condition 자체가 존재하지 않습니다.**

---

### 7. 문서를 작성하는 대신 테스트를 만드세요

- 우린 코드를 읽을 사람이 자신보다 훨씬 경험이 많이 필요한 사람이라고 가정해야 합니다.
    - 복잡한 코드는 유지보수성을 하락시킵니다.
    - 코드를 문서화하는 대신 깔끔하게 작성하고, 이에 대한 테스트를 꼼꼼하게 작성하세요.
        - 단위 테스트는 **클래스의 사용 방법을 보여줍니다.**
        - 필자는 (개념적인 측면에서) 단위 테스트까지 클래스의 일부라고 이야기합니다.

---

### 8. 모의 객체(Mcok) 대신 페이크 객체(Fake)를 사용하세요

- 모의 객체는 객체의 테스팅을 **화이트 박스 형태**로 만듭니다. 반면 페이크 객체는 **블랙 박스 형태**를 띄죠.
    - 클래스의 행위가 변경될 때 단위 테스트가 반드시 실패해야 할까요?
        - 행위가 수행하는 결과가 똑같다면 내부의 변화가 테스트에 영향을 주어선 안됩니다.
        - 하지만 행위의 내부 구현을 상세하게 명시하고 가정하는 모킹은 메서드의 결과값을 검증하는 것이 아닌 내부 구현을 검증해버립니다.
    - 이렇게 클래스의 행동 결과가 변하지 않음에도 내부 구현의 변화로 인해 테스트가 실패하는 것을 우린 **‘거짓 양성’**이라고 부릅니다.
        - 모킹을 사용하면 이런 ‘거짓 양성’이 발생합니다.
        - 테스트는 내부 구현과 행동이 아닌 **행위의 결과를 검증**해야 합니다.