# 2장 - 교육

### 1. 가능하면 적게 캡슐화하세요

- 객체가 내부적으로 객체 4개 이상을 캡슐화하고 있다면 다시 고려해보세요.
    - 쉽게 인스턴스 필드라고 표현하겠습니다. 객체 안에 4개 이상의 객체가 각각의 좌표를 갖고 있다면 이해하기 어렵습니다.

---

### 2. 최소한 뭔가는 캡슐화하세요

- 그 어떤 것도 캡슐화하고 있지 않다면 모든 객체는 어디에서든 항상 동일합니다.
    - 즉 객체가 인스턴스화 되더라도 어떤 상태나 식별자를 가지지 않고, 단순히 행동만을 포함하는 것이죠.

---

### 3. 항상 인터페이스를 사용하세요

- 객체들은 서로 자유롭게 소통하고 협력합니다. 서로를 도와주기도 하죠.
    - 이 과정에서 자연스럽게 서로가 필요합니다. 이를 우린 객체가 **‘결합된다(Coupled)’** 라고 표현합니다.
    - 하지만 수십개의 객체들이 서로 결합되면 강한 결합도를 갖는 것이 문제로 떠오릅니다.
    - 이를 해결하기 위해 객체가 서로 너무 끈끈하지 않도록 분리해줘야 하는데 이때 인터페이스가 그 역할을 착실하게 해냅니다.
- 예를 들어 금액을 표현하는 객체가 존재하고 이를 사용하는 Employee가 필요하다면 아래와 같이 구현할 수 있습니다.
    - 금액을 표현하는 객체를 클래스와 인터페이스를 통해 표현
        
        ```java
        public interface Cash {
        		Cash multiply(float factor);
        }
        
        public class DefaultCash implements Cash {
        		private int dollars;
        		
        		public DefaultCash(int dlr){
        				this.dollars = dlr;
        		}
        
        		@Override
        		Cash multiply(float factor){
        				return new DefaultCash(this.dollars * factor);
        		}
        }
        ```
        
    - 이를 사용하는 Employee는 실제 객체인 DefaultCash가 아닌 계약 ‘Cash’ 에만 의존
        
        ```java
        public class Employee {
        		private Cash salary;
        
        		public void doSomeThingWithCash(){
        				...
        				salaray.multifly(3.1);
        				...
        		}
        }
        ```
        
        - Employee는 Cash의 multiply가 어떻게 구현되었는지 모르며, 관심을 가질 필요도 없습니다.
        - 즉 객체가 객체끼리 실제 구현 방법을 다루는 ‘구현체의 타입’에 대한 의존성을 가지지 않습니다.
    - 이는 결국 서로 객체가 캡슐화된 채로 **‘느슨하게 결합’**되어 있다는 것을 의미합니다.

---