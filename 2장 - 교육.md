# 2장 - 교육

### 1. 가능하면 적게 캡슐화하세요

- 객체가 내부적으로 객체 4개 이상을 캡슐화하고 있다면 다시 고려해보세요.
    - 쉽게 인스턴스 필드라고 표현하겠습니다. 객체 안에 4개 이상의 객체가 각각의 좌표를 갖고 있다면 이해하기 어렵습니다.

---

### 2. 최소한 뭔가는 캡슐화하세요

- 그 어떤 것도 캡슐화하고 있지 않다면 모든 객체는 어디에서든 항상 동일합니다.
    - 즉 객체가 인스턴스화 되더라도 어떤 상태나 식별자를 가지지 않고, 단순히 행동만을 포함하는 것이죠.

---

### 3. 항상 인터페이스를 사용하세요

- 객체들은 서로 자유롭게 소통하고 협력합니다. 서로를 도와주기도 하죠.
    - 이 과정에서 자연스럽게 서로가 필요합니다. 이를 우린 객체가 **‘결합된다(Coupled)’** 라고 표현합니다.
    - 하지만 수십개의 객체들이 서로 결합되면 강한 결합도를 갖는 것이 문제로 떠오릅니다.
    - 이를 해결하기 위해 객체가 서로 너무 끈끈하지 않도록 분리해줘야 하는데 이때 인터페이스가 그 역할을 착실하게 해냅니다.
- 예를 들어 금액을 표현하는 객체가 존재하고 이를 사용하는 Employee가 필요하다면 아래와 같이 구현할 수 있습니다.
    - 금액을 표현하는 객체를 클래스와 인터페이스를 통해 표현
        
        ```java
        public interface Cash {
        		Cash multiply(float factor);
        }
        
        public class DefaultCash implements Cash {
        		private int dollars;
        		
        		public DefaultCash(int dlr){
        				this.dollars = dlr;
        		}
        
        		@Override
        		Cash multiply(float factor){
        				return new DefaultCash(this.dollars * factor);
        		}
        }
        ```
        
    - 이를 사용하는 Employee는 실제 객체인 DefaultCash가 아닌 계약 ‘Cash’ 에만 의존
        
        ```java
        public class Employee {
        		private Cash salary;
        
        		public void doSomeThingWithCash(){
        				...
        				salaray.multifly(3.1);
        				...
        		}
        }
        ```
        
        - Employee는 Cash의 multiply가 어떻게 구현되었는지 모르며, 관심을 가질 필요도 없습니다.
        - 즉 객체가 객체끼리 실제 구현 방법을 다루는 ‘구현체의 타입’에 대한 의존성을 가지지 않습니다.
    - 이는 결국 서로 객체가 캡슐화된 채로 **‘느슨하게 결합’**되어 있다는 것을 의미합니다.

---

### 4. 메서드 이름을 신중하게 선택하세요

- 빌더의 이름은 **명사**로, 조정자(manipulator)의 이름은 **동사**로 지으세요.
    - 빌더는 무언가를 만들고 객체를 반환하는 메서드입니다.
        - 반환 타입은 반드시 어떤 타입이어야만 합니다. 절대 `void` 가 될 수 없어요.
    - 조정자는 객체를 수정하는 메서드입니다.
        - 반환 타입은 반드시 `void` 이어야만 합니다.
- 빌더와 조정자는 각각의 역할만을 수행해야만 합니다. 둘 사이에 무언가가 존재해선 안됩니다.
    - 무언가를 조작하고 반환한다거나, 무언가를 만들며 조작하는 메서드는 있어선 안됩니다.

---

### 5. 퍼블릭 상수(Public Constant)를 사용하지 마세요

- 퍼블릭 상수는 결합도를 높히며 응집도를 낮춥니다.
    - 상수를 호출해 사용하는 방식은 객체가 변경되면 그 여파가 의존하는 객체에게 곧바로 전달됩니다.
    - 상수를 호출한다는 것은 특정 상태를 다른 객체로부터 매번 빌려온다는 것입니다. 이는 자신에게 필요한 정보가 스스로에게 없다는 것이죠.