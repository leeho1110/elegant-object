# 1장 - 출생

### 시작하기 전

- 이 책에서 객체는 항상 의인화되어 표현됩니다.
- 객체가 살아가는 환경은 **가시성 범위**로 제한됩니다.
    - 다른 객체에게 얼마만큼 노출될 것인지를 판단하는 요소입니다.
- 객체를 의인화하여 표현하고 가시성 범위를 제한하는 등, 모든 것의 목적은 실용적인 프로그래밍을 통해 **유지보수성을 향상시키는 것**입니다.

---

### 1. -er로 끝나는 이름을 사용하지 마세요

- 클래스는 흔히 붕어빵 틀로 비유되곤 합니다. 이를 하나의 개념으로 표현한다면 **‘객체의 팩토리’** 라고도 볼 수 있습니다.
    - 객체를 메모리에 올리는, 즉 인스턴스화하기 위해 필요한 도구 중 하나인 것이죠.
- 클래스 이름을 지을 땐 객체가 노출하는 행위, 즉 기능을 표현하는 이름을 지어선 안됩니다.
    - ‘무엇을 하는지(What he does)’ 가 아닌 **‘무엇인지(What he is)’**에 기반해야 합니다.
    - 객체는 캡슐화된 데이터를 핸들링하기 위해 요청하는 절차의 집합이 아닙니다.
    - 객체는 캡슐화된 데이터를 **대표하는 역할**입니다.
    - ‘-er’ 을 사용하게 되면 데이터를 표현하는 것이 아닌 데이터를 핸들링하는 절차를 표현하는 것이 되버립니다.
    - 이름을 지을 땐 객체가 **무엇을 캡슐화할 것인지 관찰**하세요.

---

### 2. 생성자 하나를 주 생성자로 만드세요

- 생성자는 ‘새로운 객체를 준비시키는 앤드포인트’입니다.
    - 생성자가 많아지면 유연해지는 장점이 있지만, 클래스가 표현하는 중심이 흐려지는 단점도 존재합니다.
- 주 생성자는 하나만 생성하고, **부 생성자가 주 생성자를 호출해 새로운 객체를 반환**하도록 하세요.

---

### 3. 생성자에 코드를 넣지 마세요

- 객체를 초기화하는 생성자에는 인자를 ‘건드리는’ 코드를 넣지마세요.
    - 만약 필요하다면 인자들을 다른 타입으로 래핑하세요.
        
        ```java
        public class Cash {
        		private Number dollars;
        	
        		// Good
        		public Cash(String dlr){
        				this.dollars = new StringAsInteger)dlr);
        		}
        
        		// Bad
        		public Cash(String dlr){
        				this.dollars = Integer.parse(dlr);
        		}
        
        		class StringAsInteger implements Number {
        				private String source;
        
        				public StringAsInteger(String src){
        						this.source = src;
        				}
        		}
        }
        ```
        
    - 진정한 객체지향이라면 작은 객체들을 조합해서 큰 객체를 만들어야 합니다.
- 이런 형태로 진행되는 경우 조금이라도 늦게, 즉 요청이 있을 때 객체에 대한 인자를 핸들링합니다.
    - 보다 나은 최적화가 가능하며, LAZY 하게 동작하죠.
    
    → (사견) 개인적으로 너무 엄격하다는 느낌을 받기도 합니다.